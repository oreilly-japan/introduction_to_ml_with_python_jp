## 『Pythonではじめる機械学習』第7刷正誤表

下記の誤りがありました。お詫びして訂正いたします。

本ページに掲載されていない誤植など間違いを見つけた方は、japan＠oreilly.co.jpまで
お知らせください。


2022年11月20日更新

p60、In[44]:<br>
【誤】
```python
plt.plot(logreg.coef_.T, 'o', label="C=1")
plt.plot(logreg100.coef_.T, '^', label="C=100")
plt.plot(logreg001.coef_.T, 'v', label="C=0.001")
plt.xticks(range(cancer.data.shape[1]), cancer.feature_names, rotation=90)
plt.hlines(0, 0, cancer.data.shape[1])
```
【正】
```python
plt.plot(logreg.coef_.T, 'o', label="C=1")
plt.plot(logreg100.coef_.T, '^', label="C=100")
plt.plot(logreg001.coef_.T, 'v', label="C=0.01")
plt.xticks(range(cancer.data.shape[1]), cancer.feature_names, rotation=90)
plt.hlines(0, 0, cancer.data.shape[1])
```

| 場所        | 誤     | 正   |
| :---------- | :--------- | :-------- |
|p61、サソリのコラム5行目 | C=0.001に対しては正になっている。|C=0.01に対しては正になっている。|
|p61、図2-17、右上の凡例 | C=1<br>C=100<br>C=0.001 | C=1<br>C=100<br>C=0.01|


p120、In[112]:、6行目<br>
【誤】
```python
for ax in axes:
    # 訓練データポイントとテストデータポイントをプロット
    # plot training and test points
    mglearn.discrete_scatter(X_test[:, 0], X_test[:, 1], y_test,
                             markers='^', ax=ax)
```
【正】
```python
for ax in axes:
    # 訓練データポイントとテストデータポイントをプロット
    mglearn.discrete_scatter(X_test[:, 0], X_test[:, 1], y_test,
                             markers='^', ax=ax)
```

p163、9行目<br>
【誤】
```python
plt.xlabel("t-SNE feature 0")
plt.xlabel("t-SNE feature 1")
```
【正】
```python
plt.xlabel("t-SNE feature 0")
plt.ylabel("t-SNE feature 1")
```

| 場所        | 誤     | 正   |
| :---------- | :--------- | :-------- |
|p179、図3-34すぐ下の段落 | 予測される通り、クラスタは完全に再現されている。scikit-learnの凝集型クラスタリング実装では、クラスタ数を指定しなければならないが、凝集型クラスタリングメソッドは正しいクラスタ数を選択する手助けをしてくれる。次は、これについて議論する。 | 予測した通り、クラスタが完全に再現されている。scikit-learnの凝集型クラスタリング実装では、あらかじめクラスタ数を指定しなければならないが、凝集型クラスタリングメソッドの結果を用いると、適切なクラスタ数の選択が容易になる。次節でこれについて説明する。|
|p179、最後の段落 | 凝集型クラスタリングを行うと、いわゆる階層型クラスタリング（hierarchical clustering）が行われる。このクラスタリングは同じ手続きを繰り返すことで行われる。すべての点は、1点しか含まれていないクラスタから最後のクラスタのいずれかへ向かっていく。繰り返しの各ステップ終了時のクラスタ数はそれぞれ異なる。すべての可能なクラスタリングを合わせて表示すると役に立つ場合がある。図3-35は、図3-33で示したすべてのクラスタリングを重ねて表示したものである。これを見ると、それぞれのクラスタがより小さいクラスタに分割されていることがわかる。 | 凝集型クラスタリングを行うと、いわゆる階層型クラスタリング（hierarchical clustering）が得られる。凝集型クラスタリングは同じ手続きを繰り返すことで行われる。すべての点は、その1点のみで構成されるクラスタからはじまり、最終的に得られるクラスタのいずれかに向けて徐々に凝集していく。この繰り返しのステップごとにクラスタの数が減っていく。この過程で得られるすべてのクラスタを重ねて表示するとわかりやすい。図3-35は、図3-33で示したすべてのクラスタを重ねて表示したものである。これを見ると、それぞれのクラスタがより小さいクラスタに分割されていることがわかる。|
|p182、17行目 | DNSCANは、クラスタはデータ中で高密度領域を構成していて | DBSCANは、クラスタはデータ中で高密度領域を構成していて|
|p199、下から4行目 | k-meansで行ったように、10クラスタを可視化してみよう（図3-46）。 | k-meansで行ったのと同様に、凝集型クラスタリングで得た10クラスタを可視化してみよう（図3-46）。|
|p213、表4-6、脚注 | age：年齢、hours-per-week：週あたりの労働時間、workclass：雇用形態、Federal-gov：国家公務員、Local-gov：地方公務員、occupation：職業、Teck-support：技術支援、Transport-moving：輸送、income：収入 | Integer Feature：整数特徴量、Categorical Feature：カテゴリ特徴量|
|p217、図4-2、凡例の訳 | ビン分割した決定木<br>ビン分割した線形回帰 | ビン分割した線形回帰<br>ビン分割した決定木|
|p224、12行目 | `Out[28]:` | `Out[27]:`|
|p300、最終行 | 交差検証の過程では分割されたデータの一部が訓練データとなり、 | 交差検証の過程では分割されたデータの一部が訓練用分割となり、|
|p301、1行目 | テストデータになる。テストデータとなった部分は、訓練データとなった部分を用いて訓練されたモデルの、新しいデータに対する性能を評価するために用いられる。しかし、実は既に、スケール変換する際に、テストデータとなった部分に含まれている情報を使ってしまっている。交差検証で用いるテストデータとして使う部分は、訓練データセットの一部であり、データの正しいスケールを決めるために、訓練データセット全体の情報を使っているからだ。 | 検証用分割になる。検証用分割となった部分は、訓練用分割となった部分を用いて訓練されたモデルの新しいデータに対する性能を評価するために用いられる。しかし、実は既に、スケール変換する際に、検証用分割となった部分に含まれている情報を使ってしまっている。交差検証で用いる検証用分割として使う部分は、訓練データセットの一部であり、データの正しいスケールを決めるために、訓練データセット全体の情報を使っているからだ。|
|p301、最後の段落 | つまり、モデル構築過程において、テストデータはまったく新しいデータでなければならないのに、この場合には交差検証のテストデータがその要件を満たしていない。テストデータになるべき部分の情報がモデル構築過程にリークしてしまっている。 | つまり、モデル構築過程において、検証データはまったく新しいデータでなければならないのに、この場合には交差検証の検証データがその要件を満たしていない。検証データになるべき部分の情報がモデル構築過程にリークしてしまっている。|
